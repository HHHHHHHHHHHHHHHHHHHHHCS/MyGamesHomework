#pragma kernel CalcPoints
#pragma kernel BlitScreen

#pragma enable_d3d11_debug_symbols


RWStructuredBuffer<float3> _Points;
RWStructuredBuffer<float3> _BezierPoints;
int _PointsCount;
float _TStep;
float4x4 _VPSMatrix;


RWTexture2D<float4> _ResultTex;
uint _Width, _Height;
uint _TCount;

//阶乘 n>=0   n=0 ->1
int Factorial(int n)
{
    int r = 1;
    [unroll(20)]
    for (int i = 1; i <= n; i++)
    {
        r *= i;
    }
    return r;
}

[numthreads(1,1,1)]
void CalcPoints(uint3 id : SV_DispatchThreadID)
{
    float3 p = float3(0, 0, 0);
    int count = _PointsCount - 1;
    float t = id.x * _TStep;
    int a = Factorial(count);

    for (int i = 0; i < _PointsCount; i++)
    {
        int b = Factorial(i);
        int c = Factorial(count - i);
        c = a * rcp(b * c);

        //compute shader 动态不确定数pow(0,0) 会nan 
        float d = count == i ? 1 : pow(abs(1.0 - t), count - i);
        float e = i == 0 ? 1 : pow(abs(t), i);
        e = c * d * e;

        p += _Points[i] * e;
    }

    p = mul(_VPSMatrix, float4(p, 1.0));
    _BezierPoints[id.x] = p;
}

[numthreads(8,8,1)]
void BlitScreen(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height)
    {
        return;
    }

    float4 col = 0;

    //这里可以对点做AABB 提前减少像素的循环次数
    for (int i = 0; i < _TCount; i++)
    {
        float2 offset = _BezierPoints[i].xy - id.xy;
        if (dot(offset, offset) < 3.0)
        {
            col = 1;
        }
    }

    _ResultTex[id.xy] = col;
}
